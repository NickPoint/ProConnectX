// tslint:disable
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ErrorMessage,
    ErrorMessageFromJSON,
    ErrorMessageToJSON,
    LoginRequest,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    MessageResponse,
    MessageResponseFromJSON,
    MessageResponseToJSON,
    SignupRequest,
    SignupRequestFromJSON,
    SignupRequestToJSON,
    UserDetailsResponse,
    UserDetailsResponseFromJSON,
    UserDetailsResponseToJSON,
} from '../models';

export interface AuthenticateUserRequest {
    loginRequest: LoginRequest;
}

export interface RegisterUserRequest {
    signupRequest: SignupRequest;
}

export interface SwitchRoleRequest {
    role: string;
}


/**
 */
function authenticateUserRaw<T>(requestParameters: AuthenticateUserRequest, requestConfig: runtime.TypedQueryConfig<T, object> = {}): QueryConfig<T> {
    if (requestParameters.loginRequest === null || requestParameters.loginRequest === undefined) {
        throw new runtime.RequiredError('loginRequest','Required parameter requestParameters.loginRequest was null or undefined when calling authenticateUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/login`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || LoginRequestToJSON(requestParameters.loginRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function authenticateUser<T>(requestParameters: AuthenticateUserRequest, requestConfig?: runtime.TypedQueryConfig<T, object>): QueryConfig<T> {
    return authenticateUserRaw(requestParameters, requestConfig);
}

/**
 */
function getCurrentUserRaw<T>( requestConfig: runtime.TypedQueryConfig<T, UserDetailsResponse> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDetailsResponseFromJSON(body), text);
    }

    return config;
}

/**
*/
export function getCurrentUser<T>( requestConfig?: runtime.TypedQueryConfig<T, UserDetailsResponse>): QueryConfig<T> {
    return getCurrentUserRaw( requestConfig);
}

/**
 */
function logoutUserRaw<T>( requestConfig: runtime.TypedQueryConfig<T, object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/logout`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function logoutUser<T>( requestConfig?: runtime.TypedQueryConfig<T, object>): QueryConfig<T> {
    return logoutUserRaw( requestConfig);
}

/**
 */
function registerUserRaw<T>(requestParameters: RegisterUserRequest, requestConfig: runtime.TypedQueryConfig<T, MessageResponse> = {}): QueryConfig<T> {
    if (requestParameters.signupRequest === null || requestParameters.signupRequest === undefined) {
        throw new runtime.RequiredError('signupRequest','Required parameter requestParameters.signupRequest was null or undefined when calling registerUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/signup`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || SignupRequestToJSON(requestParameters.signupRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MessageResponseFromJSON(body), text);
    }

    return config;
}

/**
*/
export function registerUser<T>(requestParameters: RegisterUserRequest, requestConfig?: runtime.TypedQueryConfig<T, MessageResponse>): QueryConfig<T> {
    return registerUserRaw(requestParameters, requestConfig);
}

/**
 */
function switchRoleRaw<T>(requestParameters: SwitchRoleRequest, requestConfig: runtime.TypedQueryConfig<T, object> = {}): QueryConfig<T> {
    if (requestParameters.role === null || requestParameters.role === undefined) {
        throw new runtime.RequiredError('role','Required parameter requestParameters.role was null or undefined when calling switchRole.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.role !== undefined) {
        queryParameters['role'] = requestParameters.role;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/switch-role`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function switchRole<T>(requestParameters: SwitchRoleRequest, requestConfig?: runtime.TypedQueryConfig<T, object>): QueryConfig<T> {
    return switchRoleRaw(requestParameters, requestConfig);
}

